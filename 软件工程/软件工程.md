[TOC]



# 一、课程性质与课程目标

“软件工程” 是高等教育自学考试计算机及应用专业（独立本科段）考试计划中的一门专业课。

“软件工程” 是研究软件开发的一门课程。其主要内容包括：软件开发所需要的过程、活动和任务，以及这些过程、活动和任务的组织、实施和管理。

在学习本课程之前，要求考生已学习过某一程序设计语言，最好还学习过计算机操作系统、数据库系统和数据结构等课程。

针对独立本科段的需求，本课程重点讲述软件工程开发技术，包括软件需求方法、软件设计方法以及软件测试方法。通过本课程的学习，可以具备从事软件开发的基本能力，并为软件开发的过程管理奠定一定的基础。



# 二、课程内容与考核要求

## 第1章	诸论

### 1. 总的要求

要求考生了解软件工程提出的历史背景，了解软件开发的本质，以及软件、软件工程、模型等基本概念。

> 软件开发的本质：
> ​	实现问题空间的概念和处理逻辑到解空间的概念和处理逻辑之间的映射。

### 2.知识点和考核要求

#### （1）识记

##### 	1）软件与软件工程概念。

> 软件的概念：
> ​	计算机软件一般是指计算机系统中的程序及其文档。其中，程序是计算机任务的处理对象和处理规则的描述；文档是为了理解程序所需的阐述性资料。

> 软件工程的概念：
> ​	软件工程是应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度实现满足用户要求的软件产品的工程，或以此为研究对象的学科。

##### 	2）模型概念。

> 模型的概念：
> ​	所谓模型，简单地说，是待建系统的任意抽象，其中包括所有的基本能力、特性或其他一些方面，而没有任何冗余的细节。进一步说，模型是在特定意图下所确定的角度和抽象层次上对物理系统的描述，通常包括对该系统边界的描述、对系统内各模型元素以及它们之间关系的语义描述。

#### （2）领会

##### 	1）软件工程概念的提出背景与发展历程。

> 软件工程提出的历史背景：
> ​	20世纪60年代以来，随着计算机的广泛应用，软件生产率、软件质量远远满足不了社会发展的需求，成为社会、经济发展的制约因素，人们通常把这一现象称为“软件危机”。
> ​	当时，软件开发虽然有一些工具支持，例如编译器、连接器等，但基本上还是依赖开发人员的个人技能，缺乏可遵循的原理、原则、方法体系以及有效的管理，使软件开发往往超出预期的开发时间要求和预算。
> ​	软件工程概念的提出，其目的是倡导以工程的原理、原则和方法进行软件开发，以期解决出现的“软件危机”。

> 软件工程概念提出的发展历程：
> ​	软件工程作为一门学科已有40余年的历史，其发展大体可划分为两个时期。
> ​	20世纪60年代末到80年代初，软件系统的规模、复杂性以及在关键领域的广泛应用，促进了软件的工程化开发和管理。这一时期主要围绕软件项目，开展了有关开发模型、开发方法和支持工具的研究。主要成果体现为：提出了瀑布模型，试图为开发人员提供有关活动组织方面的指导；开发了诸多过程式语言（例如，Pascal语言、C语言、Ada语言等）和开发方法（例如，Jackson方法、结构化方法等），试图为开发人员提供好的需求分析和设计手段，并开发了一些支持工具，如调试工具、测试工具等。在这一时期，开始出现各种管理方法（例如，费用估算、文件复审），开发了一些相关支持工具（例如，计划工具、配置管理工具）等。因此，这一时期的主要特征可概括为：前期主要研究系统实现技术，后期则开始关注软件质量和软件工程管理。
> ​	20世纪80年代以来，基于已开展的大量软件工程实践，围绕对软件工程的支持，开展了一系列有关软件生产技术，特别是软件复用技术和软件生产管理的研究和实践。这一时期的主要成果是提出了《软件生存周期过程》等一系列软件工程标准；大力开展了计算机辅助软件工程（CASE）的研究和实践（例如，我国在“七五”、“八五”、“九五”期间，均把这一研究作为国家重点科技攻关项目），各类CASE产品相继问世。与此同时，在工程技术方面，出现了最引人注目的面向对象语言，例如Smalltalk、C++、Riffel等；提出了面向对象软件开发方法；在工程管理方面，开展了一系列过程改进项目，其目标是在软件产品的实践中，建立一种量化的评估程序，判定软件组织和过程的成熟度，提高组织的过程能力。
> ​	近几年来，围绕网络，特别是Internet的广泛应用，以软件复用技术为基础，在软件构件技术、软件平台技术（包括应用框架）、需求工程技术、领域分析技术以及应用集成技术等方面，均取得了非常有影响的成果，有力地促进了软件工程学科和软件产业的发展。

##### 	2）求解问题的基本途径。	

> 求解问题的基本途径是软件建模。所谓软件建模，是指运用所掌握的知识，通过抽象，给出该系统的一个结构—系统模型。

##### 	3）在软件开发中的模型分类。

> 在软件开发中，软件系统模型大体上可分为两类：概念模型和软件模型。
> ​	分层的基本动机是为了控制开发的复杂性。在需求层上创建的系统概念模型是对客观事物系统的抽象，即标识要解决的问题，或称问题定义；软件模型依据所在的抽象层，可进一步分为设计模型、实现模型和部署模型等，给出需求层上概念模型的软件解决方案。

### 3.本章小结

本章简要阐述了软件开发的本质，即实现问题空间的概念和处理逻辑到解空间的概念和处理逻辑之间的映射。

在此基础上，概括地介绍了实现这一映射的基本途径，即系统建模。

所谓系统建模，是指运用所掌握的知识，通过抽象，给出该系统的一个结构—系统模型。因此，模型是一个抽象。该抽象是在意图所确定的角度和抽象层次对物理系统的一个描述，描述其中的成分和成分之间所具有的特定语义的关系，还包括对该系统边界的描述。

在软件开发领域，系统模型分为两大类，一类称为概念模型，描述了系统是什么；另一类统称为软件模型，描述了实现概念模型的软件解决方案。软件模型又可进一步分为设计模型、实现模型和部署模型等。

总之，正确认识软件开发的本质，认识建模的意义，了解模型概念以及模型分类，直接关系到对软件工程开发逻辑、开发途径有关知识的理解、掌握和正确应用。正如章首语所言：“正确认识软件开发，是从事软件开发实践和软件工程项目管理的思想基础。”



## 第2章	软件需求与软件需求规约

### 1.总的要求

要求考生在了解软件需求和需求规约概念的基础上，掌握需求和需求规约的基本特性；掌握需求分类；掌握需求发现基本技术；了解表达规约需求的基本手段；了解需求规约在软件开发中的作用。

> 需求的分类：
> 功能需求，是整个需求的主体。
> 非功能需求：性能需求、外部接口需求、设计约束和质量属性需求。

### 2.知识点和考核要求

#### （1）识记

##### 	1）需求定义以及基本特征。

> 定义：
> ​	一个需求是有关一个“要予构造”的陈述，描述了待开发产品/系统（或项）功能上的能力、性能参数或其他性质。

> 基本特征：
> ​	1) 必要的；
> ​	2) 无歧义的；
> ​	3) 可测的；
> ​	4) 可跟踪的；
> ​	5) 可测量的。

##### 	2）需求规约定义及其基本特性。

> 定义：
> ​	需求规约是一个软件项/产品/系统所有需求陈述的正式文档，它表达了一个软件产品/系统的概念模型。

> 基本特性：
> ​	1) 重要性和稳定性程度：按需求的重要性和稳定性，对需求进行分级
> ​ 2) 可修改的：在不过多的影响其他需求的前提下，可以容易地修改一个单一需求。
> ​	3) 完整的：没有被遗漏的需求。
> ​	4) 一致的：不存在互斥的需求。

#### （2）领会

##### 	1）功能需求和非功能需求，以及他们之间的基本关系。

> 功能需求：
> ​	功能需求规约了系统或系统构建必须执行的功能。

> 非功能需求：
> ​	性能需求、外部接口需求、设计约束和质量属性需求。

> 基本关系：
> ​	一般来说，功能需求是整个需求的主体，即没有功能需求，就没有派生的其他功能需求，就没有性能、外部接口、设计约束和质量属性等非功能需求。

##### 	2）需求发现技术。

> ​	1) 自悟
> ​	2) 交谈
> ​	3) 观察
> ​	4) 小组会
> ​	5) 提炼

##### 	3）规约需求的三种语言。

> ​	1) 非形式化的需求规约
> ​	2) 半形式化的需求规约
> ​	3) 形式化的需求规约

##### 	4）需求在软件开发中的作用。

> ​	1) 需求规约是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。
> ​	2) 需求规约是一个管理控制点。
> ​	3) 对于产品/系统的设计，需求规约是一个管理控制点。
> ​	4) 需求规约是创建产品验收测试计划和用户指南的基础

#### （3）应用

针对一个小型简单的系统，运用合适的需求发现技术，按一定要求的规格说明格式，以限定的自然语言给出该系统的需求规约。

### 3.本章小结

本章首先介绍了需求的定义，即“一个需求是一个‘要予构造’的陈述，描述了待开发产品（或项）功能上的能力、性能参数或者其他性质”，并指出了需求的5个必备的基本性质：必要的，即该需求是用户所要求的；无歧义的，即该需求只能用一种方式解释；可测的，即该需求是可以进行测试的；可跟踪的，即该需求可从一个开发阶段跟踪到另一个阶段；可测量的，即该需求是可测量的。需求的5个基本性质可作为需求发现和评估的基础。

其次，为了更好的理解需求，介绍了需求的分类。软件需求可以分为功能、性能、外部接口、设计约束和质量属性，并把性能、外部接口、设计约束和质量属性这4类需求统称为非功能需求。除此之外，还给出了功能需求和非功能需求的基本关系。

然后，介绍了5种常用的需求发现技术：自悟、交谈、观察、小组会和提炼，并指出采用系统化方法，例如，结构化方法和面向对象方法，可使发现的需求基本满足以上5个性质。

最后，详细的介绍了需求规约（SRS）。其中，不仅给出了需求规约的定义、需求规约的基本性质和需求规约的格式，而且还介绍了表达需求规约的3种风格：非形式化的规约、半形式化的规约和形式化的规约。

需求规约的作用可概括为以下4点：

1）需求规约是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。

2）对于项目的其余大多数工作，需求规约是一个管理控制点。

3）对于产品/系统的设计，需求规约是一个正式的、受控的起始点。

4）需求规约是创建产品验收测试计划和用户指南的基础。



## 第3章	结构化方法

### 1.总的要求

要求考生掌握结构化分析方法，并能运用该方法给出小型简单系统的功能模型；掌握结构化设计方法，能给予给定的小型简单系统功能模型，给出系统的总体设计，并能运用详细设计工具给出若干模块的详细设计。

### 2.知识点和考核要求

#### （1）识记

##### 	1）表达问题域信息的基本术语及其表示。

>  数据流：实线箭头
> ​ 加工：横椭圆
> ​ 数据存储：双横线
> ​ 数据源和数据谭：矩形

##### 	2）表达功能模型的工具——DFD图。

> 是一种描述数据变换的图形化工具，其中包含的元素可以是数据流、数据存储、加工、数据源和数据潭等。

##### 	3）数据结构符和判定表、判定树。

> 数据结构符：定义数据流程图中所有数据流和数据存储的数据结构。
> ​ 顺序结构：+
> ​ 选择结构：｜
> ​ 重复结构： { }
> ​ 子界：m..n

> 判定表：
> ​	判定表也称为决策表，是一个二维表，它说明了每一种条件组合所产生的结果。该表分为四个象限：
> +---------------+
> |条件类型|条件组合 |
> +-------+-------+
> | 操作   |操作执行|
> +-------+-------+

> 判定树：
> ​	判定树也称为决策树，是用来描述在一组不同的条件下，决策的行为是根据不同条件及其取值来选择的处理过程。业务规则的描述通常可以使用判定树这一过程描述工具。

##### 	4）变换型数据流图和事务型数据流图。

> 变换型数据流图：具有较明显的输入部分和变换部分之间界面、变换部分和输出部分之间界面的数据流图

> 事务型数据流图：数据到达一个加工T，该加工T根据输入数据的值，在其后的若干动作序列中选出一个来执行，这类数据流图称为事务型数据流图。

##### 	5）模块以及模块内聚和耦合。

> 模块：模块是执行一个特殊任务的一个过程以及相关的数据结构。

> 模块内聚：一个模块内部各成分之间相互关联程度的度量。

> 模块耦合：不同模块之间相互依赖关系的度量。

##### 	6）详细设计工具：框图、PAD图、N-S图和伪码。

> 框图：程序流程图又称为程序框图，它是历史最悠久使用最广泛的描述过程设计的方法，然而它也是用得最混乱的一种方法。

> PAD图：PAD图是问题分析图的英文缩写，自1973年由日本日立公司发明以后，已得到一定程度的推广。它用二维树形结构图表示程序的控制流，将这种图翻译为程序代码比较容易。

> N-S图：出于不允许违背结构化程序设计的考虑提出了盒图，又称为N-S图。

> 伪码：类程序设计语言PDL也称为伪码，它是用正文形式表示数据和处理过程的设计工具。

#### （2）领会

##### 	1）结构化方法源于的基本思想。

##### 	2）结构化分析方法中的每一术语所基于的原理以及它们在建模中的作用。

##### 	3）构建系统功能模型的步骤。

> 自顶向下，功能分解
> ​	建立系统环境图，确定系统语境
> ​	自顶向下，逐步求精，建立系统的层次数据流图
> ​	定义数据字典
> ​	描述加工

##### 	4）变换设计和事务设计。

##### 	5）“高内聚低耦合” 原则以及经验性准则。

> 如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。
> 内聚和耦合是密切相关的，同其他模块存在高耦合的模块常意味着是低内聚的，而高内聚的模块常意味着该模块同其他模块之间是低耦合的。在进行软件设计时，应力争做到高内聚、低耦合。

> 人们通过长期的软件开发实践，总结出一些实现模块“高内聚低耦合”的启发式规则，主要包含：
> 1）改进软件结构，提高模块独立性。
> 2）力求模块规模适中。
> 3）力求深度、宽度、扇入和扇出适中。
> 4）尽力使模块的作用域在其控制域之内。
> 5）尽力降低模块接口的复杂度。
> 6）力求模块功能可以预测。

##### 	6）详细设计工具的优缺点以及相互转换。

| 详细设计工具 | 优点                                                         | 缺点                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 程序流程图   | 对控制流程的描述很直观，便于初学者掌握                       | 1）不是一种逐步求精的工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。2）所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计。3）不易表示数据结构。 |
| 盒图         | 支持“自顶向下逐步求精”的详细设计，并且由于其以一种结构化方式严格地控制从一个处理到另一个处理的转移，因此，以盒图设计的模块一定是结构化的。为过程式高级程序设计语言提供了一整套对应的图形符号，从而将N-S图转换为对应的高级语言程序就比较容易，甚至这种转换可用软件工具自动完成，因此，可节省人工编码工作，有利于提高软件的可靠性和软件生产率。 |                                                              |
| PAD图        | 支持“自顶向下逐步求精”的设计。采用PAD图设计的模块一定是结构化的，并且所描述的程序结构也是十分清晰的。PAD图所表现出的处理逻辑易读、易懂、易记。为过程式高级程序设计语言提供了一整套对应的图形符号，从而将PAD图转换为对应的高级语言程序就比较容易，甚至这种转换可用软件工具自动完成，因此，可节省人工编码工作，有利于提高软件的可靠性和软件生产率。 |                                                              |
| PDL          | PDL是一种“混合”语言，一方面，PDL借用某种结构化程序设计语言的关键字作为语法框架，用于定义控制结构和数据结构；另一方面，PDL通常使用某种自然语言的词汇，灵活自由地表示实际操作和判定条件。PDL不仅可以作为一种设计工具，还可以作为注释工具直接插在源程序中间，以保持文档和程序的一致性，提高了文档的质量。可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的书写和编辑工作。已存在一些PDL处理工具，可以自动由PDL生成程序代码。 | 不如图形工具那样形象直观，并且当描述复杂的条件组合与动作间的对应关系时，不如判定表或判定树那样清晰简单。 |

##### 	7）结构化方法存在的问题。

> 从软件方法学研究的角度，结构化方法仍然存在一些问题，其中最主要的问题是仍然没有“摆脱”冯·诺依曼体系结构的影响，捕获的“功能（过程）”和“数据”恰恰是客观事物的易变性质，由此建造的系统结构很难与客观实际系统的结构保持一致。

#### （3）应用

​	1）针对不复杂的系统需求（问题）陈述，创建该系统的功能模型，包括系统的DFD图、数据字典和加工小说明。

​	2）在创建系统功能模型的基础上，给出该系统的总体设计，并针对有关模块运用PAD图或N-S图或伪码，给出这些模块的详细设计。

### 3.本章小结

本章比较详细的介绍了结构化方法。包括结构化需求分析方法和结构化软件设计方法，下面对结构化方法作一小结。

1）一般来说，分析是系统化的使用信息，对一个问题的估算。软件需求分析是这一概念的特化，即系统化的使用由“数据流”、“加工”、“数据存储”、“数据源”和“数据潭”等术语所表达的信息，对待建系统“是什么”给出一个估算——系统概念模型，而“软件设计是定义满足需求所需要的结构”。结构化方法作为一种特定的软件开发方法学，是从事软件分析和软件设计的一种思想工具。

2）结构化方法的提出，是基于看待客观世界的基本观点，即一切信息系统都是由信息流构成的，每一信息流都有自己的起点—数据源，有自己的归宿—数据潭，由驱动信息流动的加工，所谓信息处理主要体现为信息的流动。

3）人们解决问题的一般途径是，首先对那些非结构化和半结构化的问题，通常采用已掌握的知识，建造它们的模型定义问题；而后基于已定义的问题，给出相应的解决方案；最后采用一定的工具，实现这一解决方案。

结构化方法遵循了人们解决问题的一般途径，其中需求分析就是通过建造待开发系统/产品的概念模型，定义需求解决的问题。当采用一定技术验证后，表明该模型是可用的情况下，就可进行总体设计的详细设计，给出求解软件的一种方案，进而采用一种程序设计工具实现。当表明该模型不可使用时，那么就需要修改模型，重新验证。

4）所谓模型，简单的说，就是对任意事务的一个抽象，其中包括系统的一些基本能力、特性以及所描述的各个方面。进一步说，模型是在特定意图下所确定的角度和抽象层上，对一个物理系统的描述，给出系统内各模型元素以及它们之间的语义关系，通常还包含对该系统边界的描述。因此，采用结构化方法建立的系统功能模型，是以获得该系统功能需求为目的，从系统行为的角度，在由“数据流”、“加工”、“数据存储”、“数据源”和“数据潭”等术语所定义的需求层上，对待开发系统的描述，包括系统环境的描述。

5）为了支持系统功能建模，仅仅围绕“问题分离”、“过程抽象”、“数据抽象”等基本原则，结构化分析方法提出了5个概念，它们是数据源、数据潭、数据流、加工和数据存储，并给出了相应的表示。其中，“数据流”和“数据存储”支持对系统数据的抽象，“加工”支持系统功能/过程的抽象；“数据源”、“数据潭”以及相关的数据流支持对系统环境的描述。应该说，这些概念对于规约软件系统的功能是完备的，即它们可以“覆盖”客观世界的一切事物，并且这些概念的语义还相当简单，容易理解和掌握。

为了支持软件求解，紧紧围绕“功能/过程抽象”、“逐步求精”和“模块化”等基本软件设计原理或原则，给出了模块、模块调用等概念以及相应的表示，给出了模块结构图、PAD图、N-S图、伪码等设计工具，给出了自顶向下、功能分解的过程指导——变换设计和事务设计，并给出了实现模块化的基本准则，以提高模块的独立性。

所谓模块化，是指按照“高内聚低耦合”的设计原则，形成一个相互独立但又有较少联系的模块结构的过程，使每个模块具有相对独立的功能/过程。

所谓逐步求精，是指把要解决问题的过程分解为多个步骤或阶段，每一步是对上一步结果的精化，以接近问题的解法。逐步求精是人类解决复杂的基本途径之一。抽象和逐步求精是一对互补的概念，即抽象关注问题的主要方面，忽略其细节；而逐步求精关注底层细节的揭示。

可见，结构化方法为了支持系统建模和软件求解，基于一些软件设计原理或原则，给出了完备的符号集，给出了相应功能模型的表达工具，给出了自顶向下、逐步分解的过程指导。

6）依据5），我们可以认识到，“软件方法学是以软件方法为研究对象的学科。主要涉及指导软件设计的原理和原则，以及基于这些原理、原则的方法和技术。狭义的软件方法学也指某些特定的软件设计指导原则和方法体系“。

7）从软件方法学研究的角度，结构化方法仍然存在一些问题，其中最主要的问题是仍然没有”摆脱“冯·诺依曼体系结构的影响，捕获的”功能（过程）“和”数据“恰恰是客观事物的易变性质，由此建造的系统结构很难与客观实际系统的结构保持一致。

显然，这样的模块结构一般不会保持客观系统的结构，并且也很难维护，这是因为数据是客观事物的易变属性，一旦数据发生变化，那么不但要修改相应的数据结构，很可能要修改相关的那些模块，甚至受这些模块修改的影响，还需要修改模块结构中的其他模块，从而为系统的验证和维护带来相当大的困难，甚至是”灾难性“的。在某些意义上来讲，就是这些问题促使了面向对象方法学的产生和发展。



## 第4章	面向对象方法——UML

### 1. 总的要求

要求考生掌握在创建系统/产品模型（包括概念模型和软件模型）中用于表达信息的基本术语以及用于表达模型的用况图、类图、顺序图和状态图。

> 类的属性：类的属性是类的一个命名特性，该特性是由该类的所有对象所共享、用于表达对象状态的数据。
>
> 对象：类的一个实例。
>
> 主动类：主动类是一种至少具有一个进程或线程的类。能够启动系统的控制活动，并且其对象的行为通常是与其他元素行为并发的。
>
> 构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。
>
> 制品：制品是系统中包含物理信息的、可替代的物理部件。
>
> 节点：节点是在运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。
>
> 包：包是模型元素的一个分组，一个包本身可以被嵌套在其他包中，并且可以含有子包和其他类型的模型元素。

### 2. 知识点和考核要求

#### （1）识记

##### 	1）类、接口、用况、协作等概念。

> 类：类是一组具有相同属性、操作、关系和语义的对象的描述。
>
> 接口：接口是操作的一个集合，其中每个操作描述了类、构件或子系统的一个服务。
>
> 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。
>
> 协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容。在UML中，表示为虚线椭圆。

##### 	2）关联、泛化、实现、依赖等概念。

> 关联：关联反映了类和类之间的静态关系。关联是类目之间的一种结构关系，是对一组具有相同结构、相同链的描述。链是对象之间具有特定语义关系的抽象。（1）关联名（2）导航（3）角色（4）可见性（5）多重性：多重性定义了与一个对象/类相联系的对象/类出现一次，该对象/类出现的最小和最大的数目。（6）限定符（7）聚合：一个类是另一个类的一部分。（8）组合：聚合的一种特殊形式（9）关联类（10）约束
>
> 泛化：泛化是一般性类目和它的较为特殊性类目之间的一种关系。
>
> 实现：细化是类目之间的语义关系，其中一个类目规约了保证另一类目执行的契约。用空心三角形的虚线表示。
>
> 依赖：依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。用有向虚线段表示。

##### 	3）类图的构成。

> 类图：类图是可视化地表达系统静态结构模型的工具，通常包含类、接口、关联、泛化和依赖。

##### 	4）用况图的构成。

> 用况图：用况图是一种表达系统功能模型的图形化工具。一个用况图通常包含6个模型元素：主题、用况、参与者、关联、泛化和依赖。

##### 	5）顺序图的构成。

> 顺序图：顺序图是一种交互图，即由一组对象以及按时序组织的对象之间的关系组成，其中还包含这些对象之间所发送的消息。顺序图通常包含参与交互的对象、基本的交互方式（同步和异步）以及消息等。

##### 	6）状态以及状态图的构成。

> 状态：一个状态是类目的一个实例在其生存中的一种条件或情况，期间该实例满足这一条件，执行某一活动或等待某一消息。
>
> 状态图：状态图是显示一个状态机的图，其中强调了从一个状态到另一个状态的控制流。

#### （2）领会

##### 	1）面向对象方法源于的基本思想。

> 面向对象方法源于面向对象编程语言。

##### 	2）UML的每一术语所基于的原理以及它们在建模中的作用。

##### 	3）类的描述及其语义的表达。

> 类的属性：类的属性是类的一个命名特性，该特性是由该类的所有对象所共享、用于表达对象状态的数据。属性由属性名和属性值。每条属性可以包括属性的可见性、属性名称、类型、缺省值和约束特性。
> UML规定类的属性的语法为：
> 可见性 属性名 ：类型 多重性 = 初始值 {性质串}
> 可见性：public(+)、protected(#)、private(-)、包内的(~)

> 类的操作：操作是对一个类中所有对象要做的事情的抽象。
> UML规定操作的语法为：
> 可见性 操作名 (参数表) : 返回类型 {性质串}

##### 	4）类在建模中的作用。

> 在建立系统模型时，问题域中的大量信息均可用类来规约，形成系统模型中具有特定结构的成分。具体地说，类的作用主要有3个。
> 1. 模型化问题域中的概念（词汇）。
> 2. 建立系统的职责分布模型。
> 3. 模型化建模中使用的基本类型。

##### 	5）表达关联语义的基本手段。

> 为了表达关联的语义，UML采用了以下途径：
> （1）关联名
> （2）导航
> （3）角色
> （4）可见性
> （5）多重性
> （6）限定符
> （7）聚合。表示的是一种“整体/部分”关系。用带有空心菱形的线段表示，其中空心菱形在整体类的那一边。
> （8）组合。组合是聚合的一种特殊形式。整体类的实例和部分类的实例具有相同的生存周期。
> （9）关联类
> （10）约束

##### 	6）状态的种类及其描述。

> 在UML中，状态表示为一个圆角矩形。
>
> UML把状态分为3类，即初态、终态和通常状态。初态和终态是两种特殊状态。初态表达状态机默认的开始位置，用实心圆表示；终态表达状态机的执行以及完成，用内含一个实心圆的圆来表示。实际上，初态和终态都是伪状态，即只有名字的状态。从初态转移到正常状态可以给出一些特征，例如监护条件和动作。

##### 	7）顺序图中的操作子。

> 控制操作子：为了控制交互行为描述的复杂性，以便更清晰地表达顺序图中的复杂控制，UML给出了4种最常用的控制操作子：
> （1）选择执行操作子。
> （2）条件执行操作子
> （3）并发执行操作子
> （4）迭代执行操作子

##### 	8）正交子状态机与非正交子状态机。

> 为了有效地组织状态，控制对象状态的复杂性，UML提供了组合状态。如果在一个状态机中引入了另一个状态机，那么被引入的状态机就被称为子状态机。子状态是被嵌套在另一状态中的状态。相对地，把没有子状态的状态称为简单状态；而把含子状态的状态称为组合状态。组合状态可包含两种类型的状态机，即顺序子状态机（非正交）和并发子状态机（正交）。

### 3.本章小结

1）UML为了支持“概念建模”和“软件建模”，充分运用人类认识客观世界、解决实际问题的思维方式，提供了跨越问题空间到“运行平台”之间的建模元素。

基于给定的术语，支持不同抽象层次的确定，并提供了相应的模型表示工具。

因此可以说，UML作为一种图形化语言，紧紧围绕“面向对象方法是一种以客体和客体关系来创建系统模型的系统化软件开发方法学”，给出了比较丰富的表达事物和事物关系的术语，并给出了表达模型的工具，其主要目的是支持软件开发人员从不同角度（静态、动态）、针对不同粒度（系统、子系统、类目等），从不同抽象层来创建模型，并建立相应的文档。

2）为了支持抽象分析和设计中的事物，UML给出了8个基本术语，即类、接口、协作、用况、主动类、构件、制品、结点，并给出了这些基本术语的一些变体。每个术语都体现着一定的软件设计原理，例如类体现了数据抽象、过程抽象、局部化以及信息隐蔽等原理；用况体现了问题分离、功能抽象等原理；接口体现了功能抽象等。当使用这些术语创建系统模型时，它们的语义就映射到相应的模型元素中。

本章重点讲解了其中的类、接口和用况，简单地说明了协作、主动类、构件、制品和结点，在第5章中可能会使用它们。希望读者在需要时能参阅有关文献，以便对它们有更深入地了解并使用。

3）为了表达模型元素之间的关系，UML给出了4个术语，即关联、泛化、细化和依赖，以及它们的一些变体。可以作为UML模型中的元素，用于表达各种事物之间的基本关系。这些术语都体现了结构抽象原理，特别是泛化概念的使用，可以有效地进行“一般/特殊”结构的抽象，支持设计的复用。为了进一步描述这些模型元素的语义，还给出一些特定的概念和表示，例如给出限定符这一概念，易变增强关联的语义。

4）为了阻止以上两类模型元素，UML给出了包这一术语，在实际应用中，可以把包作为控制信息复杂性的机制。

5）为了使创建的系统（或系统成分）模型清晰、易懂，UML给出了“注解”这一术语。

6）为了表达概念模型和软件模型，UML提供了13种图形化工具，它们是类图、对象图、构件图、包图、部署图、组合结构图，以及USE CASE图、状态图、顺序图、通信图、活动图、交互概观图，定序图。前6种图可用于概念模型和软件模型的静态结构方面；而后7种模型可用于概念模型和软件模型的动态结构方面。

本章比较详细地讲解了4种表达系统（或系统成分）模型的工具。其中，类图可用于创建系统的结构模型，表达构成系统各成分之间的静态关系，给出有关系统（或系统成分）的一些说明性信息；Use Case图可用于创建有关系统（或系统成分）的功能模型，表达系统（或系统成分）的功能结构，给出有关系统（或系统成分）在功能需求方面的信息；状态图可用于创建有关系统（或系统成分）的行为生存周期模型，表达有关系统（或系统成分）的一种动态结构，给出有关系统（或系统成分）在生存期间可有哪些阶段、每一阶段可从事的活动以及对外所呈现的特征等方面的信息；顺序图可用于创建有关系统（或系统成分）的交互模型，表达系统（或系统成分）中有关对象之间的交互结构，给出系统（或系统成分）中的一些对象如何协作的信息。

本章没有讲解的模型表示工具包括对象图、构件图、包图、部署图、组合结构图，以及活动图、通信图、交互概观图和定序图。希望读者在需要时能参考有关文献，易变对它们有了解并正确使用。

另外，尽管在有的内容中提及一点UML的“公共机制”，例如衍型，但没有详细地讲解。

作为一种软件开发方法学，为了支持软件开发活动，至少包括3方面的内容：一是给出定义不同抽象层的术语；二是应给出各抽象层的模型表达工具；三是应给出如何把各层模型映射为下一个抽象层的模型，即过程指导。UML仅包括前两方面的内容，因此，UML是一种可视化的建模语言，而不是一种特定的软件开发方法学。

尽管在讲述中提到一点有关UML的应用问题，例如类的用途以及相关策略，但那是为了更好地理解，为其应用提供了一些宏观上的指导。第5章讲介绍面向对象方法学中的第3部分——过程。



## 第5章	面向对象方法——RUP

### 1.总的要求

要求考生掌握在创建系统/产品需求获取模型、需求分析模型和设计模型中的基本活动和任务，并能运用RUP建立小型简单系统的用况模型、需求分析模型，并了解RUP设计模型的基本结构，以及在设计中如何处理共性的非功能需求。

> 需求获取：RUP采用Use Case技术来获取需求。其目标是：使用UML中的用况、参与者以及依赖等术语来抽象客观实际问题，形成系统的需求获取模型——一种特定的系统/产品模型，并产生该模型视角下的体系结构描述。
> 为了实现这一目标，RUP建议开展以下工作：
> 1.列出候选需求额
> 2.理解系统语境。在RUP中，为了捕获业务处理和其中的业务对象，通过以下两个层次来抽象一个业务：
> 	（1）业务用况模型		
> 	（2）业务对象模型
> 3.捕获系统功能需求
> 	活动1:发现并描述参与者。
> 		1）任务1:发现参与者
> 		2）任务2:描述参与者
> 	活动2:发现并描述用况。
> 		1）发现用况
> 		2）描述用况
> 	活动3:确定用况的优先级。
> 	活动4:精化用况。
> 	活动5:构造用户界面原型。
> 	活动6:用况模型的结构化。

> 需求分析：RUP的需求分析目标是：在系统用况模型的基础上，创建系统分析模型以及在该分析模型视角下的体系结构描述。为了支持系统分析，RUP引入了以下术语：分析类、分析包和用况细化，并通过这些术语以及描述它们之间特定关系的术语，定义了一个抽象层。
> 创建系统的分析模型，一般应进行体系结构分析、用况分析、类的分析以及包的分析4项活动：
> 活动1:体系结构分析。
> 	1）任务1:标识分析包
> 	2）任务2:处理分析包之间的共性
> 	3）任务3:标识服务包
> 	4）任务4:定义分析包的依赖
> 	5）任务5:标识重要的实体类
> 	6）任务6:标识分析包和重要实体类的公共特定需求
> 活动2:用况分析。
> 	1）任务1:标识分析类
> 	2）任务2:描述分析（类）对象之间的交互
> 活动3:类的分析
> 	1）任务1:标识责任
> 	2）任务2:标识属性
> 	3）任务3:标识关联和聚合
> 活动4:包的分析

> 软件设计：一般地说，软件设计是定义满足需求规约所需要的软件结构。因此，RUP的设计目标是，定义满足系统/产品分析模型所规约需求的软件结构。RUP为设计层描述了4个术语：设计类、用况细化[设计]、设计子系统和接口，用于表达软件结构的基本元素。
> 设计的主要活动：
> 活动1:体系结构设计
> 	1）任务1:标识节点和它们的网络配置
> 	2）任务2:标识子系统和它们的接口
> 	3）任务3:标识在体系结构方面有意义的设计类和它们的接口
> 	4）任务4:标识一般性的设计机制
> 活动2:用况的设计
> 	1）标识参与用况细化的设计类
> 	2）标识参与用况细化的子系统和接口
> 活动3:类的设计
> 	1）任务1:概括描述设计类
> 	2）任务2:标识操作
> 	3）任务3:标识属性
> 	4）任务4:标识关联和聚合
> 	5）任务5:标识泛化
> 	6）任务6:描述方法
> 	7）任务7:描述状态
> 活动4:子系统设计
> 	1）任务1：维护子系统依赖
> 	2）任务2:维护子系统所提供的接口
> 	3）任务3:维护子系统内容

### 2. 知识点和考核要求

#### （1）识记

##### 	1）需求获取层、需求分析层、软件设计层上的术语。

> 需求获取层：
> 特征是一个新的项及其简要描述。
> 业务对象：表示那些由业务操纵的事物。
> 实在对象和概念：
> 事件：

> 需求分析层：
> 1.分析类：在RUP中，分析类是类的一种衍型，很少有操作和特征标记，而用责任来定义其行为，并且其属性和关系也是概念型的。分析类分为边界类、实体类和控制类3种：
> 	1）边界类：边界类用于规约系统与参与者之间的交互，该交互一般涉及向用户/外部系统发出请求和从它们那里接受信息。
> 	2）实体类：实体类用于规约那些需要长期驻留在系统中的模型化对象以及与行为相关的某些现象，如人的信息以及实际的一个事件。
> 	3）控制类：控制类用于规约基本动作和控制流的处理与协调，设计向其他对象（如边界类对象、实体类对象）委派工作。
> 2.用况细化：用况细化是一个协作。针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化[分析]。
> 3.分析包：分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段，形成了一些可管理的部分。

> 软件设计层：RUP为软件设计层提供了4个术语：设计类、用况细化[设计]、设计子系统和接口，用于表达软件结构中的基本元素。
> 设计类：一个设计类是对系统实现中一个类或类似构造的一个无缝抽象。
> 用况细化[设计]：用况细化[设计]是设计模型中的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的。
> 接口：接口用于规约由设计类和设计子系统提供的操作。

##### 	2）用况之间的基本关系。

> - 抽取用况描述中那些一般性的、共享的功能，并使用泛化关系标识和描述那些共享功能。
>
> - 抽取用况描述中附加的或可选的功能，可以使用扩展关系对它们进行标识和描述。
>
> - 标识用况之间的包含关系。在用况的结构化中，应注意以下3个问题：
>
>   第一个问题，在建立用况的结构中，应尽可能地反映用况的实际情况。
>
>   第二个问题，在用况的结构化中，不论是施加什么结构，新引入的用况都不应太小或太大。
>
>   第三个问题，在建立用况的机构中，应尽量避免对用况模型中的用况功能进行分解。

##### 	3）系统/产品用况模型的构成。

> 用况模型是系统的一种概念模型，是对系统功能的抽象，包括系统参与者、系统用况以及它们之间的关系。
>
> 用况模型是软件和客户就需求而达成的一个共识，是系统分析、设计、实现以及测试的基本输入。
> 给出一个系统的用况模型，主要是给出系统的用况图，给出其中每一个参与者的描述和每一个用况的描述。
> 对每一个参与者的描述，要给出其角色和对环境的要求；对每一个用况的描述，一般采用正文的事件流技术，给出用况的前置条件、开始的动作、基本路径、每一个可选路径、与参与者的交互以及结束动作和后置条件。

##### 	4）系统/产品需求分析模型构成。

> 在RUP中，一个系统的分析模型是由一个“分析系统”定义的，该分析系统包含一组具有层次结构的包，每一个包中可包含一些分析类和用况细化[分析]；并且一些分析类和用况细化[分析]还可单独出现在分析模型中，以凸显它们在系统体系结构方面的作用。

##### 	5）系统/产品设计模型和部署模型的构成。

> “设计系统”表达设计模型的顶层子系统；“设计子系统”和“设计类”，表达系统实现中子系统和构件的抽象。在设计模型中，用况是由“设计类”和“对象”予以细化，由“协作”予以表达，并通过“用况细化[设计]”予以描述的。
>
> 设计模型视角下的体系结构描述，是从设计模型的角度描述那些在体系结构方面具有意义的制品。通常，这些制品包括：
>
> 1）子系统结构，包括他们呢的接口以及它们之间的依赖。由于子系统和它们的接口构成了系统的基本结构，因此一般来说子系统的结构对系统体系结构而言是非常有意义的。
>
> 2）对体系结构由意义的设计类。
>
> 3）对体系结构由意义的用况细化[设计]。

> 部署模型：在设计期间为了表达系统的分布计算，RUP提出了部署模型。系统的部署模型是一个对象模型。一个节点表达计算资源；节点的功能（或过程）是由部署在该节点上构件所定义的。节点之间的一些关系表示节点之间的通信手段。

##### 	6）创建系统/产品需求获取模型的四个步骤。

|      基本步骤      |            相关制品            |
| :----------------: | :----------------------------: |
|  1.列出候选的特征  |             特征表             |
|   2.理解系统语境   |       领域模型或业务模型       |
| 3.捕获系统功能需求 |            用况模型            |
|  4.捕获非功能需求  | 补充的需求或针对特殊需求的用况 |

#### （2）领会

##### 	1）领域模型、业务模型以及在系统开发中创建它们的目的。

> 为了理解系统语境，往往需要创建领域模型或业务模型。
>
> 在RUP中，领域模型一般是以类图予以表达的，用于捕获系统语境中的一些重要领域对象类，其中领域对象表达系统工作环境中存在的事物或发生的事件。一般来说，领域类以3种形态出现：业务对象、实在对象、事件。

> 在RUP中，为了捕获业务处理和其中的业务对象，通过以下两个层次来抽象一个业务：
>
> （1）业务用况模型。业务用况模型是以用况图予以表达的。其中包含一些“业务用况”和一些“业务参与者”，每个业务用况对应一个业务处理，每一个业务参与者对应客户。
>
> （2）业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了3个术语，用于表达参与业务的业务对象：工作人员、业务实体和工作单元。其中，工作人员用于表达参与业务处理的各类人员；业务实体用于表达在一个业务用况中所使用的某一事物，如一张发票；工作单元是对最终用户而言可形成一个认知整体的实体的集合。业务实体和工作单元是领域类（如订单、货物项、发票等）的对象。RUP通过它们以及它们之间的关系来描述业务用况模型中的每一个业务用况，其结果称为业务对象模型。业务对象模型可通过交互图和活动图予以表达。

##### 	2）创建系统/产品用况模型的活动和任务。

> 为了创建系统的用况模型，应进行以下活动。
>
> （1）活动1：发现并描述参与者
>
> ​		1）任务1：发现参与者。
>
> ​		2）任务2：描述参与者
>
> （2）活动2：发现并描述用况。
>
> ​		1）任务1:发现用况。
>
> ​		2）任务2:描述用况。
>
> （3）活动3:确定用况的优先级。
>
> （4）活动4:精化用况。
>
> （5）活动5:构造用况界面原型。
>
> （6）活动6:用况模型的结构化。

##### 	3）参与者的标识与描述，以及标识中的有关准则。

> 参与者的标识，以及标识中的有关准则：
>
> 首先，发现一些候选的参与者，对此可分为以下两种情况。
>
> 第一种情况，即之前已存在业务用况模型，那么就可以依据这一业务模型直接发现一些候选的系统参与者，即：
>
> - 如果在业务对象模型中存在“工作人员”，就可以把每一个工作人员建议为一个候选的系统参与者。
>
> - 如果在业务用况模型中存在“业务参与者”，就可以为每一个使用该系统的业务参与者（如业务客户）建议一个候选的系统参与者。
>
> 第二种情况，之前没有业务用况模型，即使存在领域模型，也需要系统分析人员与客户一起来表示系统参与者。其中首先需要标识使用系统的人员，而后按角色对它们进行分类，形成一些候选的系统参与者。
>
> 其次，基于所发现的候选参与者，确定系统最终的参与者。
>
> 最后，在系统参与者中还需要标识表示外部系统的参与者，以及系统维护、运行所需要的参与者。



> 参与者的描述：
>
> 首先，对发现的每一系统参与者都要进行命名。对参与者给出一个恰当的名字是非常重要的，因为这样的名字可以“传达”对该参与者所期望的语义。
>
> 其次，对参与者进行描述，主要给出它的角色以及它对环境的要求，即应当概括它的责任和要求。

##### 	4）用况标识以及标识中的有关准则，用况的事件流描述技术以及描述的基本内容。

> 用况标识以及标识中的有关准则：
>
> 在UML中，用况是系统对它的参与者提供结果（值）的功能块，表达参与者使用系统的方式，因此一个用况可用于规约系统可执行的、与参与者进行交互的一个动作序列，包括其中一些可选的动作序列，并且用况还由自己的属性。
>
> 一个用况的实例，其行为表现为：系统外部的一个参与者实例，直接启动该用况实例中的一条路径，并使之处于一个开始状态。继而执行这条路径中的动作序列，使该用况实例从一个状态转化为另一状态；其中，在执行该序列的每一动作中，包含内部计算、路径选择/向某一参与者发送消息；在一个新的状态中，等待参与者发送另一外部消息，以此引发该状态下的动作执行，直到该用况实例被终止。
>
> 在建造系统用况模型中，由于把其中的每一个用况实例看作是原子的，因此只存在发生在参与者实例和用况实例之间的交互。这意味着：用况实例不能与其他用况实例发生交互，但每个用况的行为可以被其他用况所中断；在大部分情况下， 是一个参与者实例引发一个用况实例，但也有可能由一个事件所引发，如由系统之外的定时时钟所引发。

> 用况的事件流描述技术：当确定了系统的一个用况时，就应对其进行描述。该描述一般应首先给出该用况的名字；然后给出该用况的概要说明。其中，概要说明一般采用两种形式。
>
> 一种形式：简单地给出用况的功能。
>
> 另一种形式：首先给出用况实例执行的前置条件，而后一步一步地列出系统与其参与者交互时所要做的事情。
>
> RUP把这时产生的系统/产品用况模型记为用况模型[概述]。
>
> 以这一用况模型[概述]为基础，进而可形成系统的一些非功能需求和相应的应用术语集。

##### 	5）创建系统/产品需求分析模型的活动和任务。

> 创建系统的分析模型，一般应进行体系结构分析、用况分析、类的分析以及包的分析4个活动。
>
> （1）活动1:体系结构分析。
>
> ​	1）任务1:标识分析包。
>
> ​	2）任务2:处理分析包之间的共性。
>
> ​	3）任务3:表示服务包。
>
> ​	4）任务4:定义分析包的依赖。
>
> ​	5）任务5:标识重要的实体类。
>
> ​	6）任务6:标识分析包和重要实体类的公共特定需求。
>
> （2）活动2:用况分析。
>
> ​	1）任务1:标识分析类。
>
> ​	2）任务2:描述分析（类）对象之间的交互。
>
> （3）活动3:类的分析。
>
> ​	1）任务1:标识责任。
>
> ​	2）任务2:标识属性。
>
> ​	3）任务3:标识关联和聚合。
>
> （4）活动4：包的分析。

##### 	6）分析包的标识以及分析包的二层结构。

> 分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段，形成了一些可管理的部分。在一个分析包中可包含一些分析类、在分析阶段得到的用况细化，并且还可以包含其他分析包（即嵌套）。
>
> 在应用中，一般把支持一个特定业务过程的一些用况和参与者组织在一个包中，或把具有泛化或扩展关系的用况组织在一个包中。不管采用什么方式来形成分析包，一个具有良好结构的分析包，其主要特征为：
>
> - 体现问题分离。
> - 高内聚、低耦合，即包中分析类的歌责任以及用况细化[分析]各组成部分（分析类）之间是紧密相关的，而包和包之间具有比较松散的关系。
> - 尽可能体现一个系统的完整顶层设计，即尽可能成为一些子系统或称为一些子系统的组成部分。
>
> 具有以上特性的分析包才能成为一个可管理的部分。

##### 	7）边界类、实体类、控制类的标识，以及它们的作用和关系。

> 边界类：用于规约系统与其参与者之间的交互，该交互一般涉及向用户/外部系统发出请求和从他们那里接受信息。
>
> 在应用中，可用边界类来分离不同用户接口或不同通信接口，形成一个或多个边界类。
>
> |-O

> 实体类：用于规约那些需要长期驻留在系统中的模型化对象以及与行为相关的某些现象。
>
> 在大多数情况下，实体类对应业务模型中的业务类，但与业务模型中的业务类相比，一个主要区别是现在所考虑的实体类，一般是要由系统处理的那些对象。
>
> 与通常所说的设计类相比，为了理解系统依赖什么信息，实体类的粒度更大，一般表示一个具有逻辑的数据结构和属性。
>
> 在应用中，可用实体类来分离不同的信息，形成一些不同的实体类。
>
> <u>O</u>

> 控制类用于规约基本动作和控制流的处理与协调，涉及向其他对象（如边界类对象、实体类对象）委派工作。换言之，可用控制类来模型化系统的动态性，即可表达协同、定序、事务以及对其他对象的控制。
>
> 控制类封装了那些与特定用况有关的控制，表达复杂的推到和计算，如业务逻辑。尽管控制类一般要涉及其他一些对象，但不能封装那些与参与者交互有关的问题（由边界类予以封装），也不能封装那些与系统处理信息有关的问题（由实体类予以封装）。
>
> 在应用中，可用于分离一些不同的控制、协作、定序以及复杂业务逻辑，形成一些控制类。

##### 	8）用况细化 [分析] 以及用况和协作之间的基本关系。

> 用况细化是一个协作。针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化[分析]。
>
> 用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。
>
> 用况细化是一个协作，可用于对系统用况模型中的用况进行精化。换言之，用况细化将一些变化限制到对应的用况中，通过分析类之间的协作，规约用况的行为是如何实现的。

##### 	9）创建系统/产品设计模型的活动和任务。

> 为了有效地开展设计工作，在开始进行设计时，应更深入地了解以下问题。
>
> - 非功能需求。
> - 有关对程序设计语言的限制。
> - 数据库技术。
> - 用况技术。
> - 事务技术等。
>
> （1）活动1:体系结构设计。
>
> ​	1）任务1:标识节点和它们的网络配置。
>
> ​	2）任务2:标识子系统和它们的接口。
>
> ​	3）任务3:标识在体系结构方面有意义的设计类和它们的接口。
>
> ​	4）任务4:标识一般性的设计机制。
>
> （2）活动2:用况的设计。
>
> （3）活动3:类的设计。
>
> ​	1）任务1:概括描述设计类。
>
> ​	2）任务2:标识操作。
>
> ​	3）任务3:标识属性。
>
> ​	4）任务4:标识关联和聚合。
>
> ​	5）任务5:标识泛化。
>
> ​	6）任务6:描述方法。
>
> ​	7）任务7:描述状态。
>
> （4）活动4:子系统设计。
>
> ​	1）任务1:维护子系统依赖。
>
> ​	2）任务2:维护子系统所提供的接口。
>
> ​	3）任务3:维护子系统内容。

##### 	10）设计模型的四层结构。

> RUP为设计层提供了4个术语：设计类、用况细化[设计]、设计子系统和接口，用于表达软件结构中的基本元素。

> 一个设计类是对系统实现中一个类或类似构造的一个无缝抽象。设计类的主要特征有：操作、属性、关系、方法、实现需求、是否为主动类。
>
> 其中主动类是指它的对象维护自己的控制线程并与其他主动对象并发运行。

> 用况细化[设计]是设计模型中的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的。
>
> 表达协作的工具可以是类图、交互图和正文事件流等。

> 设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。
>
> 在应用中，一般通过使用服务子系统，把一些变化限制到不同的服务子系统中，形成一些封装相应变化的单个服务。

> 接口用于规约有设计类和设计子系统提供的操作。因此，接口为设计类/设计子系统提供了一种分类功能的手段。
>
> 一个接口的重要关联是细化。
>
> 但要注意，提供接口操作的设计类和设计子系统，必须提供与该接口操作对应的实现方法。
>
> 子系统之间的大多数接口，对体系结构是有意义的。

##### 	11）需求获取模型与需求分析模型的比较。

|                           用况模型                           |                         分析模型                         |
| :----------------------------------------------------------: | :------------------------------------------------------: |
|                      使用客户语言来描述                      |                   使用开发者语言来描述                   |
|                    给出的是系统对外的视图                    |                  给出的是系统对内的视图                  |
|      使用用况语义结构化，但给出的是外部视角下的系统结构      |   使用衍型类予以结构化，但给出的是内部视角下的系统结构   |
| 可以作为客户和开发者之间关于“系统应做什么、不应做什么”的契约 | 可以作为开发者理解系统如何勾画、如何设计和如何实现的基础 |
|        在需求之间可能存在一些荣誉、不一致和冲突等问题        |        在需求之间不应存在冗余、不一致和冲突等问题        |
|      捕获的是系统功能，包括在体系结构方面具有意义的功能      | 给出的是细化的系统功能，包括在体系结构方面具有意义的功能 |
|        定义了一些进一步需要在分析模型中予以分析的用况        |            定义了用况模型中的每一个用况的细化            |

##### 	12）需求分析模型与设计模型的比较。

|                         分析模型                         |                   设计模型                   |
| :------------------------------------------------------: | :------------------------------------------: |
|       概念模型，是对系统的抽象，而不涉及实现的细节       |  软件模型，是对系统的抽象，而不涉及实现细节  |
|                    可应用于不同的设计                    |                特定于一个实现                |
|         使用了3个衍型类：控制类、实体类和边界类          |       使用了多个衍型类，依赖于实现语言       |
|                     几乎不是形式化的                     |                是比较形式化的                |
|             开发的费用少（相对于设计是1:5）              |       开发的费用高（相对于分析是5:1）        |
|                        结构层次少                        |                  结构层次多                  |
|                动态的，但很少关注定序方面                |          动态的，但更多关注定序方面          |
|         概括地给出了系统设计，包括系统的体系结构         | 表明了系统设计，包括设计视角下的系统体系结构 |
|          整个软件生存周期中不能予以修改、增加等          |        整个软件生存周期中应该予以维护        |
| 为构建系统包括创建设计模型，定义一个结构，是一个基本输入 |  构建系统时，尽可能保留分析模型所定义的结构  |

#### （3）应用

##### 	1）针对一个小型简单系统，创建系统/产品用况模型、需求分析模型。

##### 	2）针对一个特定的用况，运用顺序图描述它的实现。

##### 	3）针对一个特定类，运用状态图描述其生存周期。

##### 	4）针对一个小型简单系统，运用状态图描述其生存周期。

##### 	5）针对一种共性需求（例如事物管理等），运用主动类给出它的设计。

### 3.本章小结

#### （1）RUP需求分析小结

下面对RUP的需求分析做简单总结。

（1）关于分析模型。RUP的分析如同结构化分析，其目标之一是在一个特定的抽象层上建立系统分析模型。为此，RUP首先给出了3个术语：分析包、分析类和用况细化，用于表达需求中“大粒度”的概念，开发人员使用这些术语可以规约系统分析中所要使用的信息。

​	1）分析包。分析包体现了“局部化”、“问题分离”等软件设计原理。通过“分析包”这一术语可以把系统的一些变化限制到一个业务过程、一个参与者的行为或一组紧密相关的用况，形成一些不同的系统分析包。

一个分析包中可以包含一些分析类、用况细化和一些子包。服务包和共享包是一些特殊的分析包，服务包将一些变化限制到系统提供的一些单个的服务中，并展示了一个重要的指南，即在分析期间可以通过服务包来构造复用。

通过依赖，可以形成包的一个层次结构，其中包括特定应用层和应用共享层。应用包一般位于该结构的上层，而服务包和共享包位于该结构的下层。包的层次结构可以作为系统的顶层设计。

​	2）分析类。分析类是一种粒度比较大的类，有责任、概念的属性和关系。

分析类分为边界类、实体类和控制类。在应用中，一般将用户接口、一个通信接口方面的一个变化限制到一个或多个边界类中；一般将系统所处理信息方面的一个变化限制到一个或多个实体类中；一般将控制、协调、定序、事务和复杂业务逻辑（它们要设计多个边界/实体对象）方面的一个变化限制到一个或多个控制类中。

​	3）用况细化。用况细化是一个协作，可用于对系统用况模型中的用况进行精化。换言之，用况细化将一些变换限制到对应的用况中，通过分析类之间的协作，规约用况的行为是如何实现的。

之后，规约了分析模型的语法。分析模型是对需求的一种精华，并给出了在这一抽象层上的系统结构。

最后，给出了实施系统分析的活动，支持开发人员系统化地使用以上3个术语所表达的信息，建立系统分析模型，即系统概念模型。

分析活动见下表，其中还给出了每一活动的输入/输出以及实施该活动的人员。

- 分析工作流

| 序号 |                             输入                             |     活动     |     执行者     |                      输出                      |
| :--: | :----------------------------------------------------------: | :----------: | :------------: | :--------------------------------------------: |
|  1   | 用况模型、补充需求、业务模型或领域模型、体系结构描述[用况模型] | 体系结构分析 | 体系结构设计者 | 分析包[概述]、分析类[概述]、体系结构描述[分析] |
|  2   |  用况模型、补充需求、业务模型或领域模型、体系结构描述[分析]  |   细化用况   |   用况工程师   |          用况细化[分析]、分析类[概述]          |
|  3   |                 用况细化[分析]、分析类[概述]                 |   对类分析   |   构件工程师   |                  分析类[完成]                  |
|  4   |             系统体系结构描述[分析]、分析包[概述]             | 对包进行分析 |   构件工程师   |                  分析包[完成]                  |

（2）关于分析模型视角下的体系结构描述。基于RUP的特点——以体系结构为中心，分析的目标之二是建立系统分析模型视角下的体系结构描述。

该描述表达了在体系结构方面具有重要意义的元素，包括包之间的依赖和那些具有较多关联的分析类。可见，分析模型视角下的体系结构描述将体系结构方面的一些变换限制到一些依赖和分析类的关联上。

（3）用况模型与分析模型的比较。通过下表，对用况模型和分析模型作简单比较。

|                           用况模型                           |                         分析模型                         |
| :----------------------------------------------------------: | :------------------------------------------------------: |
|                      使用客户语言来描述                      |                   使用开发者语言来描述                   |
|                    给出的是系统对外的视图                    |                  给出的是系统对内的视图                  |
|      使用用况予以结构化，但给出的是外部视角下的系统结构      |   使用衍型类予以结构化，但给出的是内部视角下的系统结构   |
| 可以作为客户和开发者之间关于“系统应做什么、不应做什么”的契约 | 可以作为开发者理解系统如何勾画、如何设计和如何实现的基础 |
|        在需求之间可能存在一些冗余、不一致和冲突等问题        |        在需求之间不应存在荣誉、不一致和冲突等问题        |
|      捕获的是系统功能，包括在体系结构方面具有意义的功能      | 给出的是细化的系统功能，包括在体系结构方面具有意义的功能 |
|        定义了一些进一步需要在分析模型中予以分析的用况        |            定义了用况模型中的每一个用况的细化            |

（4）分析模型对以后工作的影响。如果把分析模型作为以后设计活动的基本输入，那么对设计模型以及相应的体系结构描述将产生以下影响。

​	1）对设计中子系统的影响。分析包一般将影响设计子系统的结构。一般情况下，分析包和服务包分别对应设计中特定应用层的子系统和应用共享层的子系统产生影响。

特别地，在许多情况下，服务包和对应的服务子系统之间是一对一（同构）的。

​	2）对设计类的影响。分析包可以作为类设计时的规格说明。一方面，分析类以及它们的责任、属性和关系应是进行类的操作、属性和关系设计的逻辑输入。另一方面，在对具有不同衍型的分析类进行设计时，需要不用的技术和技能，如实体类的设计，常常需要使用数据库技术，而边界类的设计常常需要使用用户界面技术，当在考虑数据库技术和用户界面技术时，有关分析类的大多数特殊需求，如永久性、并发等，应由对应的设计类予以处理。

​	3）对用况细化[设计]的影响。用况细化[分析]对用况细化[设计]有两方面的作用。一个是它们有助于为用况创建更精确的规格说明。其中可采用状态图或活动图等，把每一个用况描述为分析类之间的一个协作，替代用况模型中每一个用况的事件流描述，这样就对系统需求产生了一个可理解的形式规约。另一个是当对用况进行设计时，用况细化[分析]可作为其输入。这有助于：

- 标识参与用况细化[设计]中的设计类。
- 确定用况细化[设计]中，依据所考虑的技术（数据库技术、用户界面技术），需要处理的需求，即在用况细化[分析]中所捕获的大多数特殊需求。总之，设计中应尽量地保持分析模型的结构。
- 对创建设计模型视角下体系结构描述的影响。

分析模型视角下的体系结构描述，可以作为创建设计模型视角下体系结构描述的输入。其中，通过关注跟踪依赖，不但可以使不同视图中的元素相互跟踪，而且还可以使在体系结构方面有意义的想法几乎“平稳”地“流经”不同的模型。

#### （2）RUP设计小结

下面对RUP的设计进行总结。

1）RUP设计的突出特点。RUP设计的突出特点可概括为：

- 使用了一种公共的思想来思考设计，并使设计可视化。
- 给出了有关子系统、设计类和接口的需求，为以后的实现活动创建一个合适的输入，即为系统的实现创建了一个无缝的抽象，在一定意义上讲，使实现成为设计的一个直接的精化——添加内容，而不改变其结构。这样，可以在设计和实现之间使用代码生成技术，反复不断地实现它。
- 支持对实现工作的分解，使之成为一些可以由不同开发组尽可能同时处理的、可管理的部分（显然，这一分解不可能在需求获取或分析中完成）；并且捕获了软件生存周期中早期的子系统之间的主要接口，有助于各不同开发组之间有关体系结构的思考和接口的使用。

2）关于RUP的设计方法。RUP的设计方法由3部分组成：1⃣️给出用于表达设计模型中基本成分的4个术语，包括子系统、设计类、接口和用况细化[设计]。2⃣️规约了设计模型的语法，指导模型的表达。3⃣️给出了创建设计模型的过程以及相应的指导。

3）RUP的设计模型。RUP设计的主要结果时系统的设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入。设计模型包括以下元素：

1⃣️设计子系统和服务子系统，以及它们的依赖、接口和内容。其中，可以依据分析包来设计上面两层（即特定应用层和一般应用层）的设计子系统。有关设计子系统之间的依赖，有些是基于所对应的分析包的依赖而设计的；有关子系统的接口，有些是依赖分析类而设计的。

2⃣️设计类（其中包括一些主动类），以及它们具有的操作、属性、关系及其实现需求。一般地，在进行设计类的设计时，分析类作为它们的规约，有些主动类是基于分析类病考虑并发需求而设计的。

3⃣️用况细化[设计]。它们描述了用况是如何设计的，其中使用了设计模型中的协作。一般地，在进行用况细化[设计]时，用况细化[分析]作为它们的规约。

4⃣️设计模型视角下的体系结构描述，其中包括对一些在体系结构方面有重要意义的元素的描述。如以前指出的，在设计模型视角下体系结构方面具有意义的元素设计时，分析模型视角下的那些在体系结构方面有意义的元素作为它们的规约。

4）RUP的部署模型。RUP的设计还产生了部署模型，描述了网络配置，系统将分布于这个配置上。部署模型包括：

- 节点，它们的特征以及连接。
- 主动类到节点的初始映射。

部署模型视角下的体系结构描述，包括对那些在体系结构方面具有重要意义元素的描述。

5）设计模型和分析模型的比较。

|                         分析模型                         |                   设计模型                   |
| :------------------------------------------------------: | :------------------------------------------: |
|       概念模型，是对系统的抽象，而不涉及实现的细节       |  软件模型，是对系统的抽象，而不涉及实现细节  |
|                    可应用于不同的设计                    |                特定于一个实现                |
|         使用了3个衍型类：控制类、实体类和边界类          |       使用了多个衍型类，依赖于实现语言       |
|                     几乎不是形式化的                     |                是比较形式化的                |
|             开发的费用少（相对于设计是1:5）              |       开发的费用高（相对于分析是5:1）        |
|                        结构层次少                        |                  结构层次多                  |
|                动态的，但很少关注定序方面                |          动态的，但更多关注定序方面          |
|         概括地给出了系统设计，包括系统的体系结构         | 表明了系统设计，包括设计视角下的系统体系结构 |
|          整个软件生存周期中不能予以修改、增加等          |        整个软件生存周期中应该予以维护        |
| 为构建系统包括创建设计模型，定义一个结构，是一个基本输入 |  构建系统时，尽可能保留分析模型所定义的结构  |

6）设计阶段的活动。

| 序号 |                           输入                           |     活动     |     执行者     |                             输出                             |
| :--: | :------------------------------------------------------: | :----------: | :------------: | :----------------------------------------------------------: |
|  1   | 用况模型、补充需求、分析模型、体系结构描述[分析模型角度] | 体系结构设计 | 体系结构设计者 | 子系统[概述]、接口[概述]、设计类[概述]、部署模型[概述]、体系结构描述[设计] |
|  2   |     用况模型、补充需求、分析模型、设计模型、部署模型     |   设计用况   |   用况工程师   |   用况[设计-实现]、设计类[概述]、子系统[概述]、接口[概述]    |
|  3   | 用况[设计-实现]、设计类[概述]、接口[概述]、分析类[完成]  |   对类设计   |   构件工程师   |                         设计类[完成]                         |
|  4   |       体系结构描述[设计]、子系统[概述]、接口[概述]       |  设计子系统  |   构件工程师   |                   子系统[完成]、接口[完成]                   |

7）RUP设计对实现的影响。由于设计模型和部署模型是以后实现测试活动的基本输入，因此要强调的是：

- 设计子系统和服务子系统是由实现子系统予以实现的。这些实现子系统包括一些构件，如源代码文件、脚本以及二进制、可执行的构件等。这些实现子系统可跟踪到设计子系统。
- 设计类将由文件化构件予以实现，文件化构件包括源代码。一般地，一些不同的设计类在一个单一的文件化构件中实现，尽管这依赖所使用的程序设计语言。另外，当要寻找可执行的构件时，将要使用那些描述“权重”处理的主动类。
- 在规划实现工作时，将要使用用况细化[设计]以产生一些“构造”，即系统的一个可执行的版本。每一个构造将实现一组用况细化或部分用况细化。
- 在节点上部署构件，形成分布系统时，将使用部署模型和网络配置。

#### （3）本章小结

RUP是一种软件开发过程框架，基于面向对象符号体系给出了有关软件开发过程组织及实施的指导。该框架体现了3个突出特征，即以用况驱动、体系结构为中心以及迭代、增量式开发。

RUP和UML是一对“姐妹”，它们构成了一种特定的软件开发方法学。其中，UML作为一种可视化建模语言，给出了表达事物和事物之间关系的基本术语，给出了多种模型的表达工具；而RUP利用这些术语定义了需求获取层、系统分析层】设计层、实现层，并给出了实现各层模型之间映射的基本活动以及相关的指导。

需求获取层的基本术语有：用况、参与者、用于表达用况参与者之间关系的关联、用于表达用况之间关系的包含和扩展、用于表达参与者之间关系的泛化。这些术语去定了系统用况模型的各种形态。

系统分析层的基本术语有：分析类（包括边界类、控制类和实体类）、用况细化[分析]、分析包，以及用于表达分析包之间关系的依赖、用于表达分析类之间关系的关联等。这些术语确定了系统分析模型的各种形态。

系统设计层的基本术语有：设计子系统、设计类、用况细化[设计]、接口，以及用于表达子系统之间关系的依赖、用于表达设计类之间关系的关联等。这些术语确定了系统设计模型的各种形态。

另外，在设计期间为了表达系统的分布计算，RUP提出了部署模型。系统的部署模型是一个对象模型。

其中，一个节点表达一个计算资源；节点的功能（或过程）是由部署在该节点上构件所定义的。节点之间的一些关系表示节点之间的通信手段。

为了实现各层之间系统模型的“映射”，RUP给出了相应的活动及其指导，包括：

1）需求获取的活动。

2）系统分析的活动。

3）系统设计的活动。

4）系统实现的活动。

5）系统测试的活动。



- RUP需求获取活动

| 序号 |                     输入                     |         活动         |               执行者               |            输出            |
| :--: | :------------------------------------------: | :------------------: | :--------------------------------: | :------------------------: |
|  1   |     业务模型或领域模型，补充需求，特征表     | 发现描述参与者和用况 | 系统分析员、客户、用户、其他分析员 |   用况模型[概述]，术语表   |
|  2   |       用况模型[概述]，补充需求，术语表       |    赋予用况优先级    |           体系结构设计者           | 体系结构描述[用况模型视角] |
|  3   |       用况模型[概述]，补充需求，术语表       |       精化用况       |             用况描述者             |         用况[精化]         |
|  4   | 用况[精化]，用况模型[概述]，补充需求，术语表 |   构造人机接口原型   |           人机接口设计者           |        人机接口原型        |
|  5   | 用况[精化]，用况模型[概述]，补充需求，术语表 |   用况模型的结构化   |             系统分析员             |       用况模型[精化]       |



- RUP系统分析的活动

| 序号 |                             输入                             |     活动     |     执行者     |                      输出                      |
| :--: | :----------------------------------------------------------: | :----------: | :------------: | :--------------------------------------------: |
|  1   | 用况模型、补充需求、业务模型或领域模型、体系结构描述[用况模型] | 体系结构分析 | 体系结构设计者 | 分析包[概述]、分析类[概述]、体系结构描述[分析] |
|  2   |  用况模型、补充需求、业务模型或领域模型、体系结构描述[分析]  |   细化用况   |   用况工程师   |          用况细化[分析]、分析类[概述]          |
|  3   |                 用况细化[分析]、分析类[概述]                 |   对类分析   |   构件工程师   |                  分析类[完成]                  |
|  4   |             系统体系结构描述[分析]、分析包[概述]             | 对包进行分析 |   构件工程师   |                  分析包[完成]                  |



- RUP系统设计的活动

| 序号 |                           输入                           |     活动     |     执行者     |                             输出                             |
| :--: | :------------------------------------------------------: | :----------: | :------------: | :----------------------------------------------------------: |
|  1   | 用况模型、补充需求、分析模型、体系结构描述[分析模型角度] | 体系结构设计 | 体系结构设计者 | 子系统[概述]、接口[概述]、设计类[概述]、部署模型[概述]、体系结构描述[设计] |
|  2   |     用况模型、补充需求、分析模型、设计模型、部署模型     |   设计用况   |   用况工程师   |   用况[设计-实现]、设计类[概述]、子系统[概述]、接口[概述]    |
|  3   | 用况[设计-实现]、设计类[概述]、接口[概述]、分析类[完成]  |   对类设计   |   构件工程师   |                         设计类[完成]                         |
|  4   |       体系结构描述[设计]、子系统[概述]、接口[概述]       |  设计子系统  |   构件工程师   |                   子系统[完成]、接口[完成]                   |



- RUP实现的活动

| 序号 |                            输入                            |     活动     |      执行者      |                输出                |
| :--: | :--------------------------------------------------------: | :----------: | :--------------: | :--------------------------------: |
|  1   |           设计和部署模型、体系结构描述[设计部署]           | 实现体系结构 | 体系结构设计人员 | 构件[概述]，体系结构描述[设计部署] |
|  2   |        补充需求、用况模型、设计模型、实现模型[当前]        |   集成系统   |   系统集成人员   |   集成构造计划、实现模型[当前续]   |
|  3   | 集成构造计划、实现模型[实现]、设计子系统[完成]、接口[完成] |  实现子系统  |   构件实现人员   |    实现子系统[完成]、接口[完成]    |
|  4   |                设计类[完成]、接口[设计完成]                |    实现类    |   构件实现人员   |             构件[完成]             |
|  5   |                   构件[完成]、接口[完成]                   |   单元测试   |   构件实现人员   |            构件[测试完]            |



- RUP测试的活动

| 序号 |                             输入                             |     活动     |   执行者   |        输出        |
| :--: | :----------------------------------------------------------: | :----------: | :--------: | :----------------: |
|  1   | 补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述[模型的体系结构角度] |   计划测试   | 测试工程师 |      测试计划      |
|  2   | 补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述[模型的体系结构角度]、测试计划[策略、时间表] |   设计测试   | 测试工程师 | 测试用况、测试过程 |
|  3   |          测试用况、测试过程、实现模型[被测试的建造]          |   实现测试   | 构件工程师 |      测试构件      |
|  4   |     测试用况、测试过程、测试构件、实现模型[被测试的建造]     | 执行集成测试 | 集成测试者 |        缺陷        |
|  5   |     测试用况、测试过程、测试构件、实现模型[被测试的建造]     | 执行系统测试 | 系统测试者 |        缺陷        |
|  6   |                   测试计划、测试模型、缺陷                   |   评价测试   | 测试工程师 |      测试评价      |

如章首语所说，“一种软件开发方法学至少由3部分组成，一是用于表达基于信息的术语；二是用于组织基本信息的表达格式；三是在不同抽象层之间进行“映射”的过程指导”。RUP给出的是一种过程指导，与UML一起才称得上是一种面向对象开发方法学。



## 第6章	软件测试

### 1.总的要求

要求考生掌握三种软件测试技术：基于程序路径的白盒测试技术、基于需求规约的事务流测试技术和等价类划分技术（后两种测试技术属于黑盒测试技术）；并能针对小型软件系统，运用这些技术开展相应的软件测试工作，包括用况设计、测试执行以及结果比较。

> 基于程序路径的白盒测试技术：白盒测试技术，又称为结构测试技术，典型的是路径测试技术。白盒测试技术依据的时程序的逻辑结构。
>
> 路径测试技术：由于路径测试技术依据的是程序的逻辑结构，因此该技术的基本要点是：
>
> - 采用控制流程图来表达被测程序模型，揭示程序中的控制结构。
> - 通过合理地选择一组穿过程序的路径，以达到某种测试度量。
>
> 控制流程图示一种表示程序控制结构的图形化工具，其基本元素是过程快、节点、判定。

> 基于需求规约的事务流测试技术：黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。黑盒测试技术依据的是软件行为的描述。
>
> 在事务流测试技术中，采用事务流程图作为表达被测软件模型的工具。

> 等价类划分技术：等价类划分是典型的功能测试技术。
>
> 等价类划分方法是把软件所有可能的输入数据，即软件的输入域划分成若干部分，形成一些等价类，即在一个部分中各个输入数据对于发现软件中错误的概率是一样的，然后从每一部分中选取数据作为测试用例，进行软件测试。这样，只要选取一个等价类中的一个输入数据作为测试数据进行测试而发现错误，那么使用这一等价类中的其他输入数据进行测试也回发现同样的错误；反之，若使用某一等价类中的一个输入数据作为测试数据进行测试没有查出错误，则使用这个等价类中的其他输入数据也同样查不出错误。因此，把全部输入数据合理地划分为若干等价类，其目的是用少量测试用例取得较好的测试效果。



### 2. 知识点和考核要求

#### （1）识记

##### 	1）软件测试。

> 软件测试是有规程地发现错误的过程。

##### 	2）测试过程模型。

> 软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较等。
>
> 其中，环境模型是对程序运行环境的抽象。
>
> 在进行软件测试之前，首先应建立环境模型，在这一抽象的程序运行环境中，往往只考虑被测程序中所调用的系统命令。在程序/软件测试中，建立环境模型的主要目的是，确定所发现的环境是否为环境造成的。
>
> 而后，应建立被测对象模型。该模型是从测试的角度对程序的抽象。
>
> 另外，还要建立错误模型，该模型是对程序中的错误及其分类的抽象。
>
> 在建立了环境模型、被测对象模型以及错误模型的基础上，才能设计测试用例，执行测试，并进行测试结果的比较。如果预期结果与实际结果不符，首先就要考虑是不是环境模型、被测对象模型、错误模型以及测试执行中的问题。当判断不是它们的问题时，才能认为在被测对象中存在错误。

#### （2）领会

##### 	1）路径测试中的被测试对象模型及其创建。

> 在路径测试技术中，采用控制流程图作为模型表达工具，支持创建被测程序的模型。

##### 	2）测试覆盖及其它们之间的基本关系。

> 测试策略：
>
> （1）路径覆盖。
>
> （2）语句覆盖。
>
> （3）分支覆盖。
>
> （4）条件覆盖与条件组合覆盖。
>
> 几种测试覆盖存在以下基本关系：
>
> 语句覆盖 ≤ 分支覆盖 ≤ 条件组合覆盖 ≤ …… ≤ 路径覆盖 

##### 	3）事务流和控制流之间的区别以及为测试带来的影响。

> 事务流程图是一种数据流程图，从操作应用的历史观察数据对象。因此，事务流程图与控制流程图之间的主要差异是：
>
> ​	1）基本模型元素所表达的语义不同。
>
> ​	2）一个事务不等同于路径测试中的一条路径，可能在中间某处就完成了某一用户工作，终结了一个事务。
>
> ​	3）事务流程图中的分支和节点可能是一个复杂的过程。

> 

##### 	4）事务流测试技术。

> 采用事务流测试技术进行软件测试的步骤大体分为以下4步。
>
> 第一步：获得事务流程图。
>
> 第二步：浏览、复审。
>
> 第三步：用例设计。
>
> 第四步：测试执行。

##### 	5）运用等价类划分技术进行测试的步骤。

> （1）划分等价类。划分方法：
>
> 1⃣️如果某个输入条件规定了输入数据的取值范围，则可以确立一个有效等价类和两个无效等价类。例如数值范围1～100，有效等价类"1≤x≤100"，两个无效等价类是“x<1”和“x>100”。
>
> 2⃣️如果某个输入条件规定了输入数据的个数，则可划分一个有效等价类和两个无效等价类。例如，在程序的功能规约中，规定“一名教师在一学期只能教授1～2门课程”。则有效等价类是“1≤教授课程≤2”，两个无效等价类是“不教授课程”和“教授课程超过两门”。
>
> 3⃣️如果输入条件规定了输入数据的一组可能取的值，而且程序可以对每个输入值分别进行处理，则可为每一个输入值确立一个有效等价类，而针对这组值确定一个无效等价类。例如，在高校本科生管理系统中，要对大一、大二、大三、大四的学生分别进行管理，则可确定4个有效等价类为大一、大二、大三、大四的学生，一个无效等价类是所有不符合以上身份的人员的输入值集合。
>
> 4⃣️如果输入条件是一个布尔量，则可以确立一个有效等价类和一个无效等价类。
>
> 5⃣️如果某个输入条件规定了必须符合的条件，则可划分一个有效等价类和一个无效等价类。例如，某系统中各数据项的关键字的首字符必须是K，则可划分一个有效等价类（首字符为K的输入值），一个无效等价类（首字符不为K的输入值）。
>
> 6⃣️若在已划分的某一等价类中各元素在程序中的处理方式不同，则应将此等价类进一步划分为更小的等价类。
>
> （2）设计测试用例。
>
> 根据等价类来设计测试用例，过程如下：
>
> 1⃣️为每一个等价类规定一个唯一的编号。
>
> 2⃣️设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类。重复这一步，直到所有的有效等价类都被覆盖。
>
> 3⃣️设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类。重复这一步，指导所有的无效等价类都被覆盖。
>
> 之所以这样做，是因为某些程序中对某一输入错误的检查往往会屏蔽对其他输入错误的检查。因此，设计无效等价类的测试用例时应该仅包括一个未被覆盖的无效等价类。
>
> 第一步：建立等价类表。
>
> | 输入条件     | 有效等价类             | 无效等价类           |
> | ------------ | ---------------------- | -------------------- |
> | 十六进制整数 | 1.xxx    2.xxx   3.xxx | 4.xxx   5.xxx. 6.xxx |
>
> 第二步：为有效等价类设计测试用例。
>
> 第三步：为无效等价类至少设计一个测试用例。

##### 	6）软件测试的基本步骤。

> 由于软件错误的复杂性，在软件工程测试中我们应综合运行测试技术，并且应实施合理的测试序列：单元测试、集成测试、有效性测试和系统测试。
>
> 单元测试关注每个独立的模块。单元测试主要检验软件设计的最小单元——模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。在单元测试中，由于模块不是一个独立的程序，必须为每个模块单元测试开发驱动模块和（或）承接模块。驱动模块模拟“主程序”接受测试用例的数据，将这些数据传送给要测试的模块并打印有关的结果。承接模块代替被测模块的下属模块，打印入口检查信息，并将控制返回到它的上级模块。
>
> 集成测试关注模块的组装。每个模块完成了单元测试，把它们组装在一起并不一定能够正确地工作，其原因是模块的组装存在一个接口问题。集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测试的模块构成一个满足设计要求的软件结构。
>
> 根据软件有效性的一般定义：软件实现了用户期望的功能。因此，有效性测试关注检验是否符合用户所见的文档，包括软件需求规格说明书、如那件设计规格说明书以及用户手册等。有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。
>
> 系统测试关注检验系统中所有元素（包括硬件、信息等）之间的协作是否合适，整个系统的性能、功能是否达到。其中，系统测试已超出软件测试，属于计算机系统工程范畴。

#### （3）应用

##### 	1）针对一个小型简单系统或一个特定的用况，创建系统的事物流测试模型。

##### 	2）针对一个特定的软件模块，运用白盒测试技术创建该模块的被测试对象模型，并给出相应的测试用例。

##### 	3）针对一个简单的程序，运用等价类划分技术创建其测试模型并给出相应的测试用例。

### 3.本章小结

本章主要讲解了软件测试即测试技术。首先介绍了软件测试概念，即“有规程地发现错误的过程”，其中错误是指“与所期望的设计之间的偏差，该偏差可能产生不期望的系统行为或失效”。而失效是指“与所规约的系统执行之间的偏差”。失效是系统故障或错误的后果。而故障是指“导致错误或失效的不正常的条件”。故障可以是偶然性的或是系统性的。在介绍了软件测试概念的基础上，给出了软件测试过程模型，并就其中的被测对象模型的建立、测试用例的设计以及测试执行讲解了两种主要技术——白盒测试技术和黑盒测试技术。

白盒测试技术依据程序的逻辑结构，以控制流程图作为被测对象建模的工具，其中涉及过程块、分支、节点、链以及路径，并针对测试完成，给出了4中覆盖策略：语句覆盖、分支覆盖、条件组合覆盖和路径覆盖，它们之间具有偏序关系，并且可根据项目需求给出其他覆盖策略。

黑盒测试技术依据软件行为的描述，主要讲解了事务流测试技术和等价类划分测试技术。事务流测试技术以事务流程图作为被测对象建模工具，在此基础上设计覆盖相应事务的测试用例并执行它。等价类划分测试技术以等价类表作为被测对象模型，在此基础上设计测试用例并执行它。

软件测试不但在开发中使用，而且在验证和确认的动态分析中也经常使用。动态分析是指执行程序的分析，测试为动态分析提供了必要的信息。

如章首语所说，“错误是不可避免的，因此发现错误是保障软件过程质量和软件产品质量的基础”。因此，软件测试是保障软件过程质量和软件产品质量的一种重要手段。

## 第7章	软件生存周期过程与管理

### 1.总的要求

要求考生了解围绕软件开发所需要的过程、活动和任务，掌握过程之间的基本关系，基本掌握一个软件项目的过程规划和监控。

### 2. 知识点和考核要求

#### （1）识记

##### 	1） 过程分类。

##### 	2）过程之间的关系。

#### （2）领会

##### 	1）软件实现过程、活动和任务；软件需求分析过程、活动和任务；软件体系结构设计过程、活动和任务。

##### 	2）软件验证过程、活动和任务；软件确认过程、活动和任务。

##### 	3）软件需求分析过程、软件体系结构设计过程与RUP需求获取、需求和设计之间的关系。

##### 	4）组织上使能过程的作用。

##### 	5）瀑布模型、增量模型、演化模型、螺旋模型。

##### 	6）演化模型与RUP特定 “增量迭代开发”。

##### 	7）创建一个软件项目生存周期过程的步骤。

##### 	8）监控一个软件项目生存周期过程的要点。

##### 	9）剪裁过程及其应用。

#### （3）应用

针对一个小型简单系统的开发，建立该项目的生存周期过程。

### 3.本章小结

本章讲解了软件工程的过程规划技术以及过程监控。主要内容包括：

1）软件工程需要做哪些工作，其中主要介绍了《IOS/IEC系统与软件工程-软件生存周期过程12207-2008》。

2）软件开发工作的组织，主要介绍了几个软件生存周期模型，包括瀑布模型、增量模型、演化模型、螺旋模型等，并简单分析了它们的产生背景、优缺点以及使用情况。

3）软件项目的过程规划与监控，主要介绍了项目过程的建立以及有关监控问题。

应当特别指出的是，由于过程是软件产品/系统的“生产机制”，因此开发活动的组织对软件开发十分重要，正如章首语所说“开发逻辑，是获取正确软件的关键。”

## 第8章	集成化能力成熟度模型（CMMI）

### 1.总的要求

要求考生掌握过程改善所基于的基本思想，针对开发的CMMI有关 “最佳实践”的组织以及两种过程改善的路径——能力等级和成熟度等级。

### 2. 知识点和考核要求

#### （1）识记

##### 	1）过程改善。

##### 	2）过程域、专用目标和公用目标。

##### 	3）能力等级。

##### 	4）成熟度等级。

##### 	5）过程制度化。

#### （2）领会

##### 	1）CMMI有关最佳实践的组织。

##### 	2）过程域及其分类。

##### 	3）能力等级的组成及其各等级的特征。

##### 	4）成熟度等级的组成及其各级的特征。

##### 	5）能力等级与成熟度等级之间的基本关系。

##### 	6）达到共用目标2、共用目标3、共用目标4和共用目标5所要实施的共用实践。

##### 	7）项目规划过程达到成熟度2级所要满足的专用目标、共用目标以及所要实施的实践。

##### 	8）需求开发过程域达到成熟度3级所要满足的专用目标、共用目标以及所要实施的实践。

### 3.本章小结

以下通过7点对CMMI进行小结。

1）针对开发的CMMI是一个有关产品和服务的过程改善的成熟度模型，集成了3个源模型：软件CMM、系统工程CMM和集成产品开发CMM。

2）该模型基于过程途径思想，通过过程把软件质量的3个支撑点——受训的人员、规程和方法、工具和设备进行集成，以开发所期望的系统/产品。为此，CMMI紧紧围绕开发、维护和运行，把经过证明的“最佳实践”放在一个结构中。该结构有助于指导组织确定其过程的改善优先次序；有助于指导这些改善的实施，以提高其过程能力和成熟度，并且还支持其他领域（如获取和服务）能力成熟度模型的开发。

3）CMMI提供了两种过程改善路径，一是称为能力等级的过程改善路径，该路径可使组织针对单一过程域，不断改善该过程域；二是称为成熟度等级的过程改善路径，该路径可使组织通过关注一组过程域，不断改善一组相关的过程域。

4）在第一种过程改善路径中，CMMI按不同的专用目标和共用目标，把一个过程域中“最佳实践”组织为6个不同的能力等级，分别称为：

- 0级：未完成级。
- 1级：已执行级。
- 2级：已管理级。
- 3级：已定义级。
- 4级：已定量管理级。
- 5级：持续优化级。

并按共用目标从“弱到强”，使这6个能力等级形成一个偏序。由此可见，能力等级是用来表征组织对一个过程域的改善。

5）在第二种过程改善路径中，CMMI基于ISO/IEC12207-2008等标准，首先把开发、维护、运行中的过程分为4组。

1⃣️包含7个过程域，它们是配置管理、测量与分析、项目监控、项目规划、过程和产品质量保证、需求管理、提供方协议管理。

2⃣️包含11个过程域，它们是决策分析与解决、集成项目管理、组织过程定义、组织过程关注、组织培训、产品集成、需求开发、风险管理、技能解决方案、验证、确认。

3⃣️包含两个过程域，它们是组织过程性能和定量项目管理。

4⃣️包含两个过程域，它们是原因分析与解决和组织创新与部署。

而后按每一个过程域中的不同专用目标和共用目标，以及与这些目标相关联的“最佳实践”，组织为5个不同的成熟度等级，分别称为：

- 1级：初始级。
- 2级：已管理级。
- 3级：已定义级。
- 4级：已定量管理级。
- 5级：持续优化级。

可见，CMMI按包含的过程域的多少以及相关共用目标的强弱，使这5个成熟度等级形成一个偏序，以表征组织对所关注的一组过程域的改善。

6）在CMMI中，共用目标有6个，用于表征过程制度化的程度。目标的编号越大，说明该过程的制度化程度就越高。但是，为了提高CMMI的可操作性，对于成熟度等级而言，4级和5级的过程域只要求达到共用目标3或更高。

具体地说：

1⃣️如果一个组织期望达到成熟度2级，就必须使项目规划、配置管理、测试与分析、项目监控、过程和产品质量保证、需求管理、提供方协议管理这7个过程域均达到共用目标2。

2⃣️如果一个组织期望达到成熟度3级，就要使2级所包含的过程域以及决策分析与解决、集成项目管理、组织过程定义、组织过程关注、组织培训、产品集成、需求开发、风险管理、技能解决方案、验证、确认过程域均达到共用目标3。

3⃣️如果一个组织期望达到成熟度4级，就要使2级和3级所包含的过程域以及组织过程性能、定量项目管理这两个过程域均达到共用目标3或以上。

4⃣️如果一个组织期望达到成熟度5级，就要使2级、3级、4级包含的过程域以及原因分析与解决、组织创新与部署这两个过程域均达到共用目标3或以上。

7）为了支持CMMI的应用，在该标准中还给出了一个概念：目标轮廓。一个目的轮廓定义了所有的需要予以关注的过程域，以及所针对的能力等级。

可以通过一个目标轮廓来管制在过程改善工作中应关注哪些专用目标、共用目标和实践。

通过以上7点小结可以看出，CMMI是一种过程改善模型。作为一个软件开发组织，只有具备有关过程规划和监控的能力，并不断进行过程改进，才能实现章首语所说的“仅当对软件过程予以有效管理时，才能实现有效的软件工程”。

# 三、有关说明及实施要求

## （一）关于考核要求中三个能力层次的说明

### （1）识记

“识记” 意指考生能够标识并记忆本大纲所规定的软件工程知识点，主要包括软件工程中各种工具、方法、过程的名称、含义和用途，如结构化方法、面向对象的方法、黑盒测试、白盒测试等；并能根据考题的不同要求，做成正确的选择、判断和回答。

### （2）领会

“领会” 意指考生能够领悟和理解本大纲知识点的内涵和外延，设计的概念以及概念之间的关系，并且能概括概念之间关系发生的条件和/或过程。具体在本课程中，考生应掌握和熟悉软件开发过程中方法、工具和技术的基本思想、关系、作用、目标、实施步骤和评判标准，对软件开发工作有一个总体的感受和理解。

### （3）应用

“应用” 意指考生能够运用本大纲规定的知识点，分析并解决相关的应用问题。具体到本课程中，考试能够根据实际工作的需要，将软件工程方法（如结构化方法和面向对象方法）运用的软件开发周期的各个阶段（如需求分析、系统设计、系统测试等），从而能进行问题的定义和软件功能的实现。



## （二）关于实施要求

### （1）教材

《软件工程》，全国高等教育自学考试指导委员会组编，王立福主编，刘学洋、胡文蕙编，机械工业出版社，2011年版。

### （2）自学指导

​	1）软件工程是一门技术型很强的课程，不但设计软件工程开发技术，而且还设计工程管理技术。因此希望考生尽可能参加教学点的助学辅导，尤其对那些几乎没有参加过软件项目的考生。

​	2）考生应在学习过某一计算机语言及程序设计的基础上学习本课程，最好还学习过计算机操作系统、数据库系统等课程。

​	3）考生应认真学习并理解本课程中的概念及概念之间的关系。必须认真学习并理解每章的小结。

​	4）考生应按照本大纲的三个能力层次要求，学习其中的每一个知识点。

​	5）考生应注重工程方法和技术的应用，做好每章有关应用方面的习题，如有可能，最好结合工作实践，有针对性地进行一些必要技能训练。

### （3）社会助学

​	1）助学辅导老师应按大纲讲解规定的内容把握重点，并尽可能通过项目实例讲解。

​	2）助学老师在讲解中应关注本教材内容之间的逻辑关系；关注概念、概念之间的关系以及这些关系发生的条件和过程（技术）。

​	3）助学老师应特别关注大纲中有关应用部分的训练。

​	4）助学课时。本课程3学分，相当于全日制高等学校54学时，可参阅下表来分配辅导学时：

| **章次** | **课程内容**             | **助学辅导时间（学时）** |
| -------- | ------------------------ | ------------------------ |
| **1**    | 诸论                     | 2                        |
| **2**    | 软件需求与软件需求规约   | 2                        |
| **3**    | 结构化方法               | 6                        |
| **4**    | 面向对象方法——UML        | 12                       |
| **5**    | 面向对象方法——RUP        | 16                       |
| **6**    | 软件测试                 | 6                        |
| **7**    | 软件生存周期过程与管理   | 4                        |
| **8**    | 集成化能力成熟度模型CMMI | 6                        |

### （4）关于命题和考试

​	1）考试命题：考试题型主要包括单项选择题、填空题、简单题和综合应用题。

​	2）考试方式：闭卷、笔试。考试时间为150分钟。评卷满分100分，60分为及格。

